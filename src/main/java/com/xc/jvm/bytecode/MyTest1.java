package com.xc.jvm.bytecode;


/**
 * 1.使用javap -verbose 命令分析一个字节码文件时,将会分析该字节码文件的魔数,版本号,常量池,类信息,类的构造方法
 * 类中的方法信息,类变量与成员变量等信息
 * 2.魔数:所有的.class文件的前4个字节都是魔数,固定值为:OxCAFEBABE
 * 3.版本号:魔术之后4个字节码为版本号,前两个表示minor version,后两个表示major version(主版本号)
 * 4.常量池(constant pool):紧接着主版本好之后的就是常量池入库,一个java类中定义的很多信息都是由常量此来维护和描述的
 * 可以将常量池看做是class文件的资源仓库,比如java中定义的方法与变量信息,都是存储在常量池中,常量池中主要存储连累
 * 常量:字面量与符号引用,字面量如文本字符串,java中声明为final的常量值等,而符号引用如类和接口的全局限定名,字段的
 * 名称和描述符,方法的名称和描述符
 * 5.常量池的总体结构:java类所对应的常量池主要由常量池数量与常量池数组则两个部分共同构成.常量池数量紧跟在主版本
 * 后面,占据2个字节;常量池数组紧跟在常量池数量之后.常量池数组与一般的数组不同的是,常量池数组不同元素的类型,结构都是不同.
 * 长度当然也就不同;但是每一个元素的第一个数据都是一个u1类型,该字节是个标志位,占据一个字节,jvm在解析常量池时.
 * 会根据这个u1类型来获取元素的具体类型.值得注意:常量池中元素的个数 = 常量池数 - 1 (其中0暂时不使用),目的
 * 是满足某些常量池索引值的数据在特定情况下需要表达[不引用任何一个常量池]的含义;根本原因在于,索引0也是一个常量(保留常量),
 * 只不过它不位于常量表中,这个常量就对应null值,所以,常量池的索引从1而非0开始
 *
 *
 */
public class MyTest1 {

    private int a = 1;


    public int getA() {
        return this.a;
    }

    public void setA(int a) {
        this.a = a;
    }

}
