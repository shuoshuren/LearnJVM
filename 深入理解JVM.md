# 深入理解jvm
##1. 类加载阶段分析
###1.在Java代码中，类型的加载，连接与初始化过程都在程序运行期间完成的
###2.在以下几种情况下，jvm将结束生命周期：
1》执行了System.exit()方法
2》程序正常执行结束
3》程序在执行过程中遇到了异常或者错误二异常终止
4》由于操作系统出现错误而导致jvm进程终止
###3.类的加载，连接与初始化
1》加载：查找并加载类的二进制数据
2》连接：
	1》验证：确保被加载的类的正确性
	2》准备：为类的静态变量分配内存，并将其初始化为默认值
	3》解析：把类中的符号引用转换为直接引用
3》初始化：为类的静态变量赋予正确的初始值
4> 类实例化:
为新对象分配内存
为实例变量赋默认值
为实例变量赋正确的初始值
java编译器为编译的每一个类都至少生成一个实例初始化方法.在class文件中,这个实例方法
初始化方法被称为`<init>`方法
### 类的使用与卸载

##2.类的加载,连接与初始化
+ 1.java程序对类的使用方式分为两种:`主动使用`和`被动使用`
+ 2.所有的java虚拟机必须实现在类或者接口被java程序`首次主动使用`时才初始化他们
主动使用:
+ 1.创建类的实例
+ 2.访问某个类或接口的静态变量,或者对该静态变量赋值
+ 3.调用类的静态方法
+ 4.反射
+ 5.初始化一个类的子类
+ 6.jvm启动被表明为启动类的类(Java Test)
+ 7.jdk1.7提供动态语言的支持:java.lang.invoke.MethodHandle实例的结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化,则初始化
除了上面7种情况,其他使用java类的方法都是被动使用,都不会导致类的初始化
###类的加载
+ 1.类的加载指将类的.class文件中的二进制数据读入内存中,将其放到运行时数据区的方法区内,然后在内存中创建一个java.class.Class对象(规范未说明Class对象位于哪里,HotSpot虚拟机将其放在方法区中),用来放纵类在方法区内的数据结构
+ 2.加载.class文件的方式
	1>.从本地系统中直接加载
	2>.通过网络下载.class文件
	3>.从zip,jar等归档文件中加载.class文件
	4>从专有数据库中提取.class文件
	5>将java源文件动态编译为.class文件
+ 有两种类型的类加载器
1.java自带的加载器:根类加载器(bootstrap),扩展类加载器(Extension),系统(应用)类加载器(System)
2.用户自定义的类加载器:java.lang.ClassLoader的子类

类加载去并不需要等到某个类被`首次主动使用`时在加载它
JVM规范:允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载过程中遇到.class文件确实或者错,类
加载器必须在`程序首次主动使用`该类时才报告错误(LinkageError错误)
如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误

### 类的验证
类验证的内容:
类文件的结构检查
语义检查
字节码验证
二进制兼容性的验证

### 类的初始化时机
当jvm初始化一个类时,要求它的所有父类都已经初始化,这条规则并不适用于接口:
在初始化一个类时,并不会先初始化它所实现的接口
在初始化一个接口时,并不会先初始化它的父接口
因此,一个父接口并不会因为它的子接口或者实现类的初始化而初始化,只有当程序首次适用特定
接口的静态变量时,才会导致该接口的初始化
调用ClassLoader类的loadClass方法加载一个类,并不是对于一个类的主动适用,不会导致类的初始化

### 类加载器
类加载器用来把类加载到JVM.从jdk1.2开始,类加载过程采用双亲委托机制,这种机制能够更好保证java平台安全.
在次委托机制中,除了JVM自带的更类加载器外,其他的类加载器有且只有一个父加载器.当java程序请求加载loader
加载类时,loader首先委托直接的父加载器去加载类,若父加载器能加载,则由父加载器加载任务,否则才由loader本身加载类

获取ClassLoader:
获取当前类的ClassLoader:`clazz.getClassLoader();`
获取当前线程上下文的ClassLoader:`Thread.currentThread().getContextClassLoader();`
获取系统的ClassLoader:`ClassLoader.getSystemClassLoader();`
获取调用者的ClassLoader:`DirverManager.getCallerClassLoader();`

### 命名空间
1.每个类加载器都有自己的命名空间,命名空间有该加载器及所有父加载器所有类组成
2.在同一个命名空间中,不会出现类的完整名字(包括类的包名)相同的两个类
3.在不同的命名空间中,有可能会出现类完整名字(包括类的包名)相同的两个类

### 不同类加载器的关系
1.同一个命名空间的类是相互可见的
2.子加载器的命名空间包含所有父加载器的命名空间,因此,由子类加载的器加载的类能看见
父加载器加载的类,有父加载器加载的类不能看见子加载器加载的类
3.如果两个加载器之间没有直接或间接的父子关系,那么他们加载的类相互看不见

### 类的卸载
由JVM自带的类加载器所加载的类,在jvm的生命周期中,始终不会被卸载.由用户自定义的类
加载器所加载的类是可以被卸载的










