# 深入理解jvm
##1. 类加载阶段分析
###1.在Java代码中，类型的加载，连接与初始化过程都在程序运行期间完成的
###2.在以下几种情况下，jvm将结束生命周期：
1》执行了System.exit()方法
2》程序正常执行结束
3》程序在执行过程中遇到了异常或者错误二异常终止
4》由于操作系统出现错误而导致jvm进程终止
###3.类的加载，连接与初始化
1》加载：查找并加载类的二进制数据
2》连接：
	1》验证：确保被加载的类的正确性
	2》准备：为类的静态变量分配内存，并将其初始化为默认值
	3》解析：把类中的符号引用转换为直接引用
3》初始化：为类的静态变量赋予正确的初始值
4> 类实例化:
为新对象分配内存
为实例变量赋默认值
为实例变量赋正确的初始值
java编译器为编译的每一个类都至少生成一个实例初始化方法.在class文件中,这个实例方法
初始化方法被称为`<init>`方法
### 类的使用与卸载

##2.类的加载,连接与初始化
+ 1.java程序对类的使用方式分为两种:`主动使用`和`被动使用`
+ 2.所有的java虚拟机必须实现在类或者接口被java程序`首次主动使用`时才初始化他们
主动使用:
+ 1.创建类的实例
+ 2.访问某个类或接口的静态变量,或者对该静态变量赋值
+ 3.调用类的静态方法
+ 4.反射
+ 5.初始化一个类的子类
+ 6.jvm启动被表明为启动类的类(Java Test)
+ 7.jdk1.7提供动态语言的支持:java.lang.invoke.MethodHandle实例的结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化,则初始化
除了上面7种情况,其他使用java类的方法都是被动使用,都不会导致类的初始化
###类的加载
+ 1.类的加载指将类的.class文件中的二进制数据读入内存中,将其放到运行时数据区的方法区内,然后在内存中创建一个java.class.Class对象(规范未说明Class对象位于哪里,HotSpot虚拟机将其放在方法区中),用来放纵类在方法区内的数据结构
+ 2.加载.class文件的方式
	1>.从本地系统中直接加载
	2>.通过网络下载.class文件
	3>.从zip,jar等归档文件中加载.class文件
	4>从专有数据库中提取.class文件
	5>将java源文件动态编译为.class文件
+ 有两种类型的类加载器
1.java自带的加载器:根类加载器(bootstrap),扩展类加载器(Extension),系统(应用)类加载器(System)
2.用户自定义的类加载器:java.lang.ClassLoader的子类

类加载去并不需要等到某个类被`首次主动使用`时在加载它
JVM规范:允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载过程中遇到.class文件确实或者错,类
加载器必须在`程序首次主动使用`该类时才报告错误(LinkageError错误)
如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误

### 类的验证
类验证的内容:
类文件的结构检查
语义检查
字节码验证
二进制兼容性的验证

### 类的初始化时机
当jvm初始化一个类时,要求它的所有父类都已经初始化,这条规则并不适用于接口:
在初始化一个类时,并不会先初始化它所实现的接口
在初始化一个接口时,并不会先初始化它的父接口
因此,一个父接口并不会因为它的子接口或者实现类的初始化而初始化,只有当程序首次适用特定
接口的静态变量时,才会导致该接口的初始化
调用ClassLoader类的loadClass方法加载一个类,并不是对于一个类的主动适用,不会导致类的初始化

### 类加载器
类加载器用来把类加载到JVM.从jdk1.2开始,类加载过程采用双亲委托机制,这种机制能够更好保证java平台安全.
在次委托机制中,除了JVM自带的更类加载器外,其他的类加载器有且只有一个父加载器.当java程序请求加载loader
加载类时,loader首先委托直接的父加载器去加载类,若父加载器能加载,则由父加载器加载任务,否则才由loader本身加载类

获取ClassLoader:
获取当前类的ClassLoader:`clazz.getClassLoader();`
获取当前线程上下文的ClassLoader:`Thread.currentThread().getContextClassLoader();`
获取系统的ClassLoader:`ClassLoader.getSystemClassLoader();`
获取调用者的ClassLoader:`DirverManager.getCallerClassLoader();`

### 命名空间
1.每个类加载器都有自己的命名空间,命名空间有该加载器及所有父加载器所有类组成
2.在同一个命名空间中,不会出现类的完整名字(包括类的包名)相同的两个类
3.在不同的命名空间中,有可能会出现类完整名字(包括类的包名)相同的两个类

### 不同类加载器的关系
1.同一个命名空间的类是相互可见的
2.子加载器的命名空间包含所有父加载器的命名空间,因此,由子类加载的器加载的类能看见
父加载器加载的类,有父加载器加载的类不能看见子加载器加载的类
3.如果两个加载器之间没有直接或间接的父子关系,那么他们加载的类相互看不见

### 类的卸载
由JVM自带的类加载器所加载的类,在jvm的生命周期中,始终不会被卸载.由用户自定义的类
加载器所加载的类是可以被卸载的

## Java 字节码
class字节码有两种数据类型
1.字节数据直接量:基本的数据类型.共细分为u1,u2,u4,u8四种,分别代表连续的1个字节,
2个字节,4个字节,8个字节组成的整体数据
2.表(数组):表是由多个基本数据或其他表,安装既定顺序组成的大的数据集合.表是有结构的,体现在:
组成表的成分所在的位置和顺序都是已经严格定义好的.

## jvm
jvm运行时内存数据区域
1.程序计数器
2.本地方法栈
3.java虚拟机栈:(线程隔离)java虚拟机栈描述的是java方法的执行模型:每个方法执行的时候都会创建一个帧(frame)
栈用于存放局部变量表,操作栈,动态连接,方法出口等信息,一个方法的执行过程,就是这个方法对于帧栈的入栈出栈的过程
4.堆(heap):堆里存放的是对象的实例,是jvm管理内存最大的一块,gc主要的工作区域,是线程共享的
5.方法区域:存放每个class的结构信息,包括常量池,字段描述,方法描述,GC的非主要工作区域

## jvm垃圾回收(GC)模型
1.垃圾判断算法
2.GC算法
3.垃圾回收器的实现和选择

### 垃圾判断的算法
### 引用计算算法(Reference Counting)
1.给对象添加一个引用计算器,当有一个地方引用它,计数器+1,当引用失效,计数器-1,
任何时刻计数器为0的对象就是不可能再被使用的
2.引用计数器算法无法解决对象循环引用的问题
### 根搜索算法 (GC Roots Tracing)
1.在实际的生产语言中(java,c#),都是使用根搜索算法判断对象是否存活
2.算法思路就是通过一系列的被称为"GC Roots"的点作为起始点进行向下搜索,当一个对象到GC roots没有任何引用链(Reference Chain)
相连,则证明此对象是不可用的
在java中GC Roots指:
1>在vm栈(帧中的本地变量)中的引用
2>方法区的静态引用
3>JNI(native方法)中的引用

GC主要回收两部分内容:废弃常量与无用类
类回收需要满足以下3个条件
1.该类的所有实例都已经被GC,也就是jvm中不存在该class的任何实例
2.加载该类的classloader已经被GC
3.该类对应的class对象没有在任何地方被引用,如不能在任何地方通过反射访问该类的方法

###jvm常见GC算法:
1.标记-清除算法(mark-sweep)
2.标记-整理算法(mark-compact)
3.复制算法(copying)
4.分代算法(Generational)

###标记-清除算法 (mark-sweep)
1.算法分为"标记"和清除两个阶段,首先标记出所有需要回收的对象,然后回收所有需要回收的对象
缺点:
效率问题,标记和清理两个过程效率都不高:需要扫描所有对象,堆越大,GC越慢
空间问题,标记清理之后会产生大量不连续的内存碎片,空间碎片太多可能会导致后续使用中无法找到足够的连续内存
而提前触发另一次的垃圾收集动作

### 标记-整理(mark-compact)算法
1.标记过程仍然一样,但后续步骤不是进行直接清理,而是令所有存活的对象一段移动,
然后直接清理掉这段边界以外的内存
2.没有内存碎片
3.比mark-sweep耗费更多的时间进行compact

### 复制(copying)收集算法
1.将可用内存划分为两块,每次只是用其中的一块,当半区内存用完了,仅将还存活的对象复制到另外一块上面,然后将
将原来整块内存空间一次性清理掉
2.每次内存回收都是对整个半区的回收,内存分配时也就不用考虑内存碎片等复杂情况,只要移动堆顶指针,按照顺序分配内存即可,
实现简单,运行高效.只是这种算法的代价是将内存缩小为原来的一半,代价高昂.
3.现在商业jvm都是用这种收集算法回收新生代
4.将内存分为一块较大的eden空间和2块较少的Survivor空间,每次使用eden和其中一块Survivor,当回收时将eden和survivor还存活的对象一次性拷贝到另一块Survivor空间
然后清理掉eden和使用的survivor
5.hotspot jvm默认eden和survivor大小是8:1,每次只有10%内存是浪费的
6.复制收集算法在对象存活率高的时候,效率有所下降
7.如果不想浪费50%的空间,需要有额外空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况,
所以在老年代一般不能直接选用这种算法
8.只需要扫描存活的对象,效率高,不会产生碎片
9.需要浪费额外的内存作为复制区,非常适合生命周期比较短的对象,因为每次gc都能
回收大部分的对象,复制开销比较小

### 分代收集(Generational Collecting)算法
1.分代收集算法:根据对象不同的存活周期将内存划分为几块,
2.一般将java堆分为新生代和老年代,根据
各个年代的特点采用最适合的收集算法,新生代每次GC都有大批对象死去,只有少量存活,就采用复制算法就只需要
付出少量存活对象的复制成本就可以完成收集
3.jvm6中共划分为新生代,老年代和永久代
4.年轻代(Young Generation):新生成的对象都放到新生代上,年轻代用复制算法进行GC
新生代分为3个区,一个eden区,两个survivor区,eden和Survivor比例为8:1
5.老年代(old generation):存放经过一次或者多次GC还存活的对象,一般采用mark-sweep或者mark-compact算法进行GC
6.永久代:并不属于堆(Heap),但是GC也会涉及到这个区域,存放每个class的机构信息,包括常量池,字段描述,方法描述,与GC要收集的java对象关系不大

### 内存分配
1.堆上分配:大多数情况在eden上分配,偶尔会直接在old上分配,细节取决与GC实现
2.栈上分配:原子类型的局部变量

### 内存回收
hotspot认为没有引用的对象是dead的
hotspot将引用分为4种:Strong,soft,weak,phantom
在full gc时,会对Reference类型的引用进行特殊处理
1.soft:内存不够时一定会被gc,长期不用也会被GC
2.weak:一定会被gc,当被mark为dead,会在ReferenceQueue中通知
3.phantom:本身就没引用,当从jvm heap中释放时会通知

### GC的时机
1.在分代模型的基础上,GC从时机上分为两种:Scavenge GC和Full GC
2.Scavenge GC(Minor GC):
触发时机:新对象生成时,Eden空间满了,理论上Eden空间大部分对象会在Scavenge GC回收,复制算法的执行效率会很高,GC时间较短
3.Full GC
对整个JVM进行整理,包括Yong,Old和Perm
主要触发时机:old满了,Perm满了,system.gc()
效率很低,尽量减少Full Gc

###垃圾收集器的并行与并发
1.并行(parallel):指多个收集器的线程同时工作,但是用户线程处于等待状态
2.并发(Concurrent):指收集器在工作的同时,可以允许用户线程工作

### 垃圾收集器
#### Serial收集器:
1>最早的单线程收集器,收集时会暂停所有的工作线程(Stop the world,STW),使用复制收集算法,jvm允许在client
模式时的默认新生代收集器
2>在新生代采用复制算法,在老年代,采用mark-compact算法
3>单线程GC,没有多线程切换的额外开销,简单使用

#### ParNew收集器
ParNew就是serial的多线程版本,是JVM运行在server模式的默认新生代收集器,在单cpu环境中,不会比serial收集器更好
可以通过-XX:ParallelGCThreads来控制GC线程数的多少,需要结合cpu的核数

#### Parallel Scavenge收集器
1.多线程收集器,也是采用复制算法,但是对象分配规则和回收策略都与ParNew不同,是以吞吐量最大化(GC占中运行时间最小)为目标
的收集器实现,允许较长时间的STW换取总吞吐量最大化

#### Parallel Old收集器
老年代版本吞吐量优先收集器,使用多线程和标记-整理算法,JVM1.6提供
Parallel Scavenge + Parallel Old = 高吞吐量,当GC停顿可能不会理想

#### CMS(Concurrent Mark Swap)收集器
CMS是一种以最短停顿时间为目标的收集器,使用CMS并不能达到GC效率最高(总体GC时间最小),当它能尽可能降低GC时服务的停顿时间
CMS收集器使用的是标记-清除算法
1.只针对老年代,一般结合Parallel New来使用
2.GC线程和用户线程并发工作,只有在多cpu环境下才有意义,使用-XX:+UseConcMarkSweepGC打开
3.cms以牺牲CPU资源的代价来减少用户线程的停顿,在清理时,用户线程还在跑,需要预留一部分空间给用户线程
4.CMS用mark-sweep,会带来碎片问题,碎片过多少会容易频繁触发Full GC










