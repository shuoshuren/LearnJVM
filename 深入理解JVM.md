# 深入理解jvm
##1. 类加载阶段分析
###1.在Java代码中，类型的加载，连接与初始化过程都在程序运行期间完成的
###2.在以下几种情况下，jvm将结束生命周期：
1》执行了System.exit()方法
2》程序正常执行结束
3》程序在执行过程中遇到了异常或者错误二异常终止
4》由于操作系统出现错误而导致jvm进程终止
###3.类的加载，连接与初始化
1》加载：查找并加载类的二进制数据
2》连接：
	1》验证：确保被加载的类的正确性
	2》准备：为类的静态变量分配内存，并将其初始化为默认值
	3》解析：把类中的符号引用转换为直接引用
3》初始化：为类的静态变量赋予正确的初始值
4> 类实例化:
为新对象分配内存
为实例变量赋默认值
为实例变量赋正确的初始值
java编译器为编译的每一个类都至少生成一个实例初始化方法.在class文件中,这个实例方法
初始化方法被称为`<init>`方法
### 类的使用与卸载

##2.类的加载,连接与初始化
+ 1.java程序对类的使用方式分为两种:`主动使用`和`被动使用`
+ 2.所有的java虚拟机必须实现在类或者接口被java程序`首次主动使用`时才初始化他们
主动使用:
+ 1.创建类的实例
+ 2.访问某个类或接口的静态变量,或者对该静态变量赋值
+ 3.调用类的静态方法
+ 4.反射
+ 5.初始化一个类的子类
+ 6.jvm启动被表明为启动类的类(Java Test)
+ 7.jdk1.7提供动态语言的支持:java.lang.invoke.MethodHandle实例的结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化,则初始化
除了上面7种情况,其他使用java类的方法都是被动使用,都不会导致类的初始化
###类的加载
+ 1.类的加载指将类的.class文件中的二进制数据读入内存中,将其放到运行时数据区的方法区内,然后在内存中创建一个java.class.Class对象(规范未说明Class对象位于哪里,HotSpot虚拟机将其放在方法区中),用来放纵类在方法区内的数据结构
+ 2.加载.class文件的方式
	1>.从本地系统中直接加载
	2>.通过网络下载.class文件
	3>.从zip,jar等归档文件中加载.class文件
	4>从专有数据库中提取.class文件
	5>将java源文件动态编译为.class文件
+ 有两种类型的类加载器
1.java自带的加载器:根类加载器(bootstrap),扩展类加载器(Extension),系统(应用)类加载器(System)
2.用户自定义的类加载器:java.lang.ClassLoader的子类

类加载去并不需要等到某个类被`首次主动使用`时在加载它
JVM规范:允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载过程中遇到.class文件确实或者错,类
加载器必须在`程序首次主动使用`该类时才报告错误(LinkageError错误)
如果这个类一直没有被程序主动使用,那么类加载器就不会报告错误

### 类的验证
类验证的内容:
类文件的结构检查
语义检查
字节码验证
二进制兼容性的验证

### 类的初始化时机
当jvm初始化一个类时,要求它的所有父类都已经初始化,这条规则并不适用于接口:
在初始化一个类时,并不会先初始化它所实现的接口
在初始化一个接口时,并不会先初始化它的父接口
因此,一个父接口并不会因为它的子接口或者实现类的初始化而初始化,只有当程序首次适用特定
接口的静态变量时,才会导致该接口的初始化
调用ClassLoader类的loadClass方法加载一个类,并不是对于一个类的主动适用,不会导致类的初始化

### 类加载器
类加载器用来把类加载到JVM.从jdk1.2开始,类加载过程采用双亲委托机制,这种机制能够更好保证java平台安全.
在次委托机制中,除了JVM自带的更类加载器外,其他的类加载器有且只有一个父加载器.当java程序请求加载loader
加载类时,loader首先委托直接的父加载器去加载类,若父加载器能加载,则由父加载器加载任务,否则才由loader本身加载类

获取ClassLoader:
获取当前类的ClassLoader:`clazz.getClassLoader();`
获取当前线程上下文的ClassLoader:`Thread.currentThread().getContextClassLoader();`
获取系统的ClassLoader:`ClassLoader.getSystemClassLoader();`
获取调用者的ClassLoader:`DirverManager.getCallerClassLoader();`

### 命名空间
1.每个类加载器都有自己的命名空间,命名空间有该加载器及所有父加载器所有类组成
2.在同一个命名空间中,不会出现类的完整名字(包括类的包名)相同的两个类
3.在不同的命名空间中,有可能会出现类完整名字(包括类的包名)相同的两个类

### 不同类加载器的关系
1.同一个命名空间的类是相互可见的
2.子加载器的命名空间包含所有父加载器的命名空间,因此,由子类加载的器加载的类能看见
父加载器加载的类,有父加载器加载的类不能看见子加载器加载的类
3.如果两个加载器之间没有直接或间接的父子关系,那么他们加载的类相互看不见

### 类的卸载
由JVM自带的类加载器所加载的类,在jvm的生命周期中,始终不会被卸载.由用户自定义的类
加载器所加载的类是可以被卸载的

## Java 字节码
class字节码有两种数据类型
1.字节数据直接量:基本的数据类型.共细分为u1,u2,u4,u8四种,分别代表连续的1个字节,
2个字节,4个字节,8个字节组成的整体数据
2.表(数组):表是由多个基本数据或其他表,安装既定顺序组成的大的数据集合.表是有结构的,体现在:
组成表的成分所在的位置和顺序都是已经严格定义好的.

## jvm
jvm运行时内存数据区域
1.程序计数器
2.本地方法栈
3.java虚拟机栈:(线程隔离)java虚拟机栈描述的是java方法的执行模型:每个方法执行的时候都会创建一个帧(frame)
栈用于存放局部变量表,操作栈,动态连接,方法出口等信息,一个方法的执行过程,就是这个方法对于帧栈的入栈出栈的过程
4.堆(heap):堆里存放的是对象的实例,是jvm管理内存最大的一块,gc主要的工作区域,是线程共享的
5.方法区域:存放每个class的结构信息,包括常量池,字段描述,方法描述,GC的非主要工作区域

## jvm垃圾回收(GC)模型
1.垃圾判断算法
2.GC算法
3.垃圾回收器的实现和选择

### 垃圾判断的算法
### 引用计算算法(Reference Counting)
1.给对象添加一个引用计算器,当有一个地方引用它,计数器+1,当引用失效,计数器-1,
任何时刻计数器为0的对象就是不可能再被使用的
2.引用计数器算法无法解决对象循环引用的问题
### 根搜索算法 (GC Roots Tracing)
1.在实际的生产语言中(java,c#),都是使用根搜索算法判断对象是否存活
2.算法思路就是通过一系列的被称为"GC Roots"的点作为起始点进行向下搜索,当一个对象到GC roots没有任何引用链(Reference Chain)
相连,则证明此对象是不可用的
在java中GC Roots指:
1>在vm栈(帧中的本地变量)中的引用
2>方法区的静态引用
3>JNI(native方法)中的引用

GC主要回收两部分内容:废弃常量与无用类
类回收需要满足以下3个条件
1.该类的所有实例都已经被GC,也就是jvm中不存在该class的任何实例
2.加载该类的classloader已经被GC
3.该类对应的class对象没有在任何地方被引用,如不能在任何地方通过反射访问该类的方法

###jvm常见GC算法:
1.标记-清除算法(mark-sweep)
2.标记-整理算法(mark-compact)
3.复制算法(copying)
4.分代算法(Generational)

###标记-清除算法 (mark-sweep)
1.算法分为"标记"和清除两个阶段,首先标记出所有需要回收的对象,然后回收所有需要回收的对象
缺点:
效率问题,标记和清理两个过程效率都不高:需要扫描所有对象,堆越大,GC越慢
空间问题,标记清理之后会产生大量不连续的内存碎片,空间碎片太多可能会导致后续使用中无法找到足够的连续内存
而提前触发另一次的垃圾收集动作

### 标记-整理(mark-compact)算法
1.标记过程仍然一样,但后续步骤不是进行直接清理,而是令所有存活的对象一段移动,
然后直接清理掉这段边界以外的内存
2.没有内存碎片
3.比mark-sweep耗费更多的时间进行compact

### 复制(copying)收集算法
1.将可用内存划分为两块,每次只是用其中的一块,当半区内存用完了,仅将还存活的对象复制到另外一块上面,然后将
将原来整块内存空间一次性清理掉
2.每次内存回收都是对整个半区的回收,内存分配时也就不用考虑内存碎片等复杂情况,只要移动堆顶指针,按照顺序分配内存即可,
实现简单,运行高效.只是这种算法的代价是将内存缩小为原来的一半,代价高昂.
3.现在商业jvm都是用这种收集算法回收新生代
4.将内存分为一块较大的eden空间和2块较少的Survivor空间,每次使用eden和其中一块Survivor,当回收时将eden和survivor还存活的对象一次性拷贝到另一块Survivor空间
然后清理掉eden和使用的survivor
5.hotspot jvm默认eden和survivor大小是8:1,每次只有10%内存是浪费的
6.复制收集算法在对象存活率高的时候,效率有所下降
7.如果不想浪费50%的空间,需要有额外空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况,
所以在老年代一般不能直接选用这种算法
8.只需要扫描存活的对象,效率高,不会产生碎片
9.需要浪费额外的内存作为复制区,非常适合生命周期比较短的对象,因为每次gc都能
回收大部分的对象,复制开销比较小

### 分代收集(Generational Collecting)算法
1.分代收集算法:根据对象不同的存活周期将内存划分为几块,
2.一般将java堆分为新生代和老年代,根据
各个年代的特点采用最适合的收集算法,新生代每次GC都有大批对象死去,只有少量存活,就采用复制算法就只需要
付出少量存活对象的复制成本就可以完成收集
3.jvm6中共划分为新生代,老年代和永久代
4.年轻代(Young Generation):新生成的对象都放到新生代上,年轻代用复制算法进行GC
新生代分为3个区,一个eden区,两个survivor区,eden和Survivor比例为8:1
5.老年代(old generation):存放经过一次或者多次GC还存活的对象,一般采用mark-sweep或者mark-compact算法进行GC
6.永久代:并不属于堆(Heap),但是GC也会涉及到这个区域,存放每个class的机构信息,包括常量池,字段描述,方法描述,与GC要收集的java对象关系不大

### 内存分配
1.堆上分配:大多数情况在eden上分配,偶尔会直接在old上分配,细节取决与GC实现
2.栈上分配:原子类型的局部变量

### 内存回收
hotspot认为没有引用的对象是dead的
hotspot将引用分为4种:Strong,soft,weak,phantom
在full gc时,会对Reference类型的引用进行特殊处理
1.soft:内存不够时一定会被gc,长期不用也会被GC
2.weak:一定会被gc,当被mark为dead,会在ReferenceQueue中通知
3.phantom:本身就没引用,当从jvm heap中释放时会通知

### GC的时机
1.在分代模型的基础上,GC从时机上分为两种:Scavenge GC和Full GC
2.Scavenge GC(Minor GC):
触发时机:新对象生成时,Eden空间满了,理论上Eden空间大部分对象会在Scavenge GC回收,复制算法的执行效率会很高,GC时间较短
3.Full GC
对整个JVM进行整理,包括Yong,Old和Perm
主要触发时机:old满了,Perm满了,system.gc()
效率很低,尽量减少Full Gc

###垃圾收集器的并行与并发
1.并行(parallel):指多个收集器的线程同时工作,但是用户线程处于等待状态
2.并发(Concurrent):指收集器在工作的同时,可以允许用户线程工作

### 垃圾收集器
#### Serial收集器:
1>最早的单线程收集器,收集时会暂停所有的工作线程(Stop the world,STW),使用复制收集算法,jvm允许在client
模式时的默认新生代收集器
2>在新生代采用复制算法,在老年代,采用mark-compact算法
3>单线程GC,没有多线程切换的额外开销,简单使用

#### ParNew收集器
ParNew就是serial的多线程版本,是JVM运行在server模式的默认新生代收集器,在单cpu环境中,不会比serial收集器更好
可以通过-XX:ParallelGCThreads来控制GC线程数的多少,需要结合cpu的核数

#### Parallel Scavenge收集器
1.多线程收集器,也是采用复制算法,但是对象分配规则和回收策略都与ParNew不同,是以吞吐量最大化(GC占中运行时间最小)为目标
的收集器实现,允许较长时间的STW换取总吞吐量最大化

#### Parallel Old收集器
老年代版本吞吐量优先收集器,使用多线程和标记-整理算法,JVM1.6提供
Parallel Scavenge + Parallel Old = 高吞吐量,当GC停顿可能不会理想

#### CMS(Concurrent Mark Swap)收集器
CMS是一种以最短停顿时间为目标的收集器,使用CMS并不能达到GC效率最高(总体GC时间最小),当它能尽可能降低GC时服务的停顿时间
CMS收集器使用的是标记-清除算法
1.只针对老年代,一般结合Parallel New来使用
2.GC线程和用户线程并发工作,只有在多cpu环境下才有意义,使用-XX:+UseConcMarkSweepGC打开
3.cms以牺牲CPU资源的代价来减少用户线程的停顿,在清理时,用户线程还在跑,需要预留一部分空间给用户线程
4.CMS用mark-sweep,会带来碎片问题,碎片过多少会容易频繁触发Full GC

### java内存泄露的原因
1.对象定义在错误的访问(Wrong Scrope)
2.异常(Exception)处理不当
3.集合数据管理不当

###CMS
#### 枚举根节点
当执行系统停顿下来后,并不需要一个不漏的检查完所有执行上下文和全局引用位置,虚拟机应当是有办法直接
知道哪些地方存放着对象引用,在HotSpot的实现中,是使用一组称为OOpMap的数据结构来达到这个目的的
#### 安全点
在OopMap的协助下,hotSpot可以快速且准确得完成GC Roots模具,但是一个现实的问题随之而来:可能导致引用关系
变化,或者所OopMap内容变化的指令非常多,如果为每一条指令都生成对应的OopMap,那将会需要大量的额外空间,这样GC
的空间成本将会很高.
实际上,HotSpot并没有为每条指令生成OopMap,而是在"特定位置"记录这些信息,这些位置称为安全点(safepoint),即程序
执行时并非在所有地方都能停顿下来开始GC,只有在达到安全点才能暂停.
安全点选定即不能太少以至于让GC等待时间太长,也不能过于频繁以至于过分增大运行时的负载,所以,安全点的选定基本是以
"是否具有让程序长时间执行的特征"为标准进行选定--因为每条指令执行的时间非常短暂,程序不太可能因为指令流长度太长这个原因
而过长时间运行,"长时间执行"的最明显特征就是指令序列复用,例如方法调用,循环跳转,异常跳转等,所以具有这些功能
的指令才会参数safepoint
对于safepoint,另一个需要考虑的问题是如何zaiGC发生时让所有线程(不包括执行JNI调用的线程)都跑到最近的安全点上再停顿下来:
抢占式中断(Preemptive Suspension)和主动式中断(Voluntary Suspension)
抢占式中断:不需要线程的执行代码自动去配合,在GC发生时,首先把所有的线程全部中断,如果有线程中断的地方不在安全点,就恢复线程,让他
跑到安全点.
主动式中断:当GC需要中断线程时,不直接对线程操作,仅仅简单设置一个标志,各个线程执行时主动轮休这个标志,当发现中断标志为真时就自己中断挂起.
轮询标志的地方和安全点是重合的,另外在加上创建对象需要分配内存的地方
现在几乎没有jvm采用抢占式中断来暂停线程从而响应GC事件
#### 安全区域
safepoint机制保证程序执行时,在不太长时间就会遇到可进入GC的safepoint,当如果程序在"不执行"的时候?
程序不执行就是没有分配cpu时间,典型例子就是处于sleep或者blocked状态,线程就无法响应JVM的中断请求,对于
这种情况需要安全区域(safe Region)来解决
在线程执行到safe region的代码时,首先标示自己已经进入safe region,当这段时间jvm要发生gc时,就不用管表示为safe
region状态的线程,当线程要离开safe region时,要检查系统是否已经完成根节点枚举(或整个GC过程),如果完成,那线程就继续执行,否则
它必须等待直到收到可以安全离开safe region的信号为止

#### CMS收集器
CMS(Concurrent Mark Sweep)收集器,以获取最短回收停顿时间为目标,多数应用与互联网站或者B/S系统的服务器上
CMS基于"标记-清除"算法实现,整个过程分为4个步骤:
1.初始标记(CMS initial mark):只是标记一下GC Root能直接关联到的对象,速度很快
2.并发标记(CMS concurrent mark):就是进行GC Roots Traacing 的过程
3.重新标记(CMS remark):为修正并发标记期间赢用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但比并发标记的时间短.
4.并发清除(CMS Concurrent sweep):
其中初始标记和重新标记需要"Stop the world".在整个过程中耗时长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作,因此,从总体来看,CMS收集器的内存回收过程是与用户线程一起并发执行的.

优点:并发收集,低停顿
缺点:CMS收集器对CPU资源敏感
CMS收集器无法处理浮动垃圾(Floating Garbage),可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生.可适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比
收集结束时会有大量空间碎片产生,空间碎片过多时,会对大对象分配带来很大麻烦.不得不提前进行一次Full GC.CMS收集器提供了-XX:+UseCMSCompactAtFullCollection开关参数.用于在CMS收集器顶不住要进行Full Gc时开启内存碎片的合并整理过程.
对于堆比较大的引用,GC的时间难以预估

#### 空间分配担保
在发生Minor GC之前,JVM会先检查老年代最大可用连续空间是否大于新生代所有对象总空间,如果条件成立,那么Minor GC可用确保是安全的.当大量对象在Minor GC后仍然存活,就需要老年代进行空间分配担保,把Survivor无法容纳的对象直接进入老年代,如果老年代判断剩余空间不足(根据以往每次回收晋升到老年代对象容量的平均值作为经验值),则进行一次Full GC

### G1 (Garbage first Collector)
#### 吞吐量
吞吐量关注的是在一个指定的时间内,最大化一个应用的工作量.对关注吞吐量的系统,卡顿是可以接受的,因为这个系统关注长时间的大量任务的执行能力,单次快速的响应并不值得考虑

#### 响应能力
响应能力指一个程序或者系统对请求能否能够及时响应,对于这类对响应能力敏感的场景,长时间的停顿是无法接受.

#### G1 设计目标
1.与应用线程同时工作,几乎不需要stop the world(与CMS类似)
2.整理剩余空间,不产生内存碎片(CMS 只能在FUll GC时,用stop the world 整理内存碎片),G1基于copying算法
3.GC停顿更加可控;
4.不牺牲系统的吞吐量;
5.gc不要求额外的空间内存(CMS需要预留空间存储浮动垃圾);

#### G1 收集器堆结构
1.heap被划分为一个个相等的不连续的内存区域(regions),每个region都有一个分代的角色:eden,survivor,old
2.对每个角色的数量并没有强制的限定,也就是说对每种分代内存的大小,可以动态变化
3.G1最大的特点是高效的执行回收,优先执行哪些大量对象可回收的区域(region)
4.G1使用gc停顿可预测的模型,来满足用户设定的gc停顿时间,根据用户设定的目标时间,g1会自动选择哪些region要清除,一次清除多少个region
5.g1从多个region中复制存活的对象,然后集中放入一个region中,同时整理,清除内存(copying收集算法)

#### G1的重要概念
1.分区(Region):G1采用了不同的策略来解决并行,串行和CMS收集器的碎片,暂停时间不可控等问题--G1将整个堆分成了大小相同的分区(Region)
2.每个分区可能是新生代,老年代,但是同一时刻只能属于某个代.年轻代,幸存区,老年代这些概念还存在,成为逻辑上的概念.方便复用之前分代框架的逻辑
3.在物理上不需要连续,带来了额外的好处--有的分区类垃圾对象特别多,有的分区类垃圾对象很少,G1会优先收集垃圾对象特别多的分区,可以花费较少的时间来回收这些分区的垃圾,这也是G1名字的由来,首先收集垃圾最多的分区
4.依然是在新生代满了的时候,对整个新生代进行回收---整个新生代中对象,要么被回收,要么晋升,这与新生代也采用分区机制的原因,则是因为这样根老年代的策略统一,方便调整代的大小
5.G1还是一种带压缩的收集器,在回收老年代的分区时,将存活的对象从一个分区拷贝到另一个可用分区,这个拷贝过程实现局部压缩
6.收集集合(CSet):一组可被回收的分区的集合.在CSet存活的数据会在GC过程被移动到另一个可用分区,CSet中分区可用来自eden空间,survivor空间,或者老年代
7.已记忆集合(RSet):Rset记录了其他region中对象引用本Region中对象的关系,属于points-into结构(谁引用了我的对象).RSet价值在于使得垃圾收集器不需要扫描这个堆找到谁引用了当前分区中的对象,只需要扫描RSet即可
8.Snapshot-At-The-Beginning(SATB):G1 GC在并发标记阶段使用的增量式的标记算法,并发标记是并发多线程的,但是并发线程是在同一时刻只扫描一个分区

#### G1相对CMS优势
1.G1在压缩空间方面有优势
2.G1通过将内存空间分成区域(Region)的方式避免内存碎片问题
3.Eden,survivor,old区不在固定,在内存使用效率上来说更灵活
4.g1可以通过设置预期停顿时间(Pause Time)来控制垃圾收集时间,避免应用雪崩现象
5.g1在回收内存后会马上同时做合并空闲内存的工作,而cms默认是在stw的时候做
6.g1会在Yong GC中使用,而CMS只能在O区使用

#### G1 GC模式
1.G1提供两种GC模式:Yong GC和Mixed GC,两种都是完全的stop the world的
2.Young GC:选定所有年轻代里的Region,通过控制年轻代的Region个数,即年轻代内存大小,来控制young GC的时间开销
3.Mixed GC:选定所有年轻代里的Region,外加根据global concurrent marking统计得出收集收益高的若干老年代Region.在用户指定的开销目标范围内尽可能选择收益高的老年代Region
4.Mixed GC不是Full GC,它只能回收部分老年代的Region,如果mixed GC实在无法跟上程序分配内存的速度,导致老年代谈判无法继续进行Mixed GC,就会使用serial old GC(Full GC)来收集整个GC heap.所以本质上,G1不提供Full GC的

G1运行过程:会在Young GC和Mixed GC之间不断切换运行,同时定期做全局并发标记,在实在赶不上对象创建速度的情况下使用Full GC(Serial GC)
初始标记是在Young GC上执行的,在进行全局并发标记的时候不会做Mixed GC,在做Mixed GC的时候也不会启动初始标记阶段,当Mixed GC赶不上对象产生的速度时,就退化层FUll GC

#### global concurrent marking
global concurrent marking的执行过程类似与CMS,但是不同的是,在G1 gc中,主要是为Mixed GC提供标记服务的,并不是一次GC过程中的必须环节.
执行分为4个步骤:
1.初始标记(initial mark,STW):标记了从GC Root开始直接可达的对象
2.并发标记(Concurrent marking):这个阶段从GC root开始对heap中对象进行标记,标记线程与应用程序线程并发执行,并且收集各个Region的存活对象信息
3.重新标记(Remark,STW):标记哪些在并发标记阶段发生变化的对象,将被回收
4.清理(CLeanup):清除空Region(没有存活对象的),加入到free list

第一阶段initial mark是共用Young GC的暂停,因为可以复用root scan操作,所以可以说global concurrent marking是伴随young gc而发生的
第四阶段cleanup只是回收了没有存活对象的region,所以并不需要stw

#### G1运行中的主要模式
1.YGC:在eden充满时触发,在回收之后,所有之前属于eden的区块全部变成空白,即不属于任何一个分区
2.Mixed GC:由一些参数控制,另外也控制着哪些老年代Region会被选入CSet
G1HeapWastePerent:在 global Concurrent marking结束之后,可以知道old gen region中有多少空间要被回收,在每次YGC之后和再次发生Mixed GC之前,会检查垃圾占比是否达到此参数,只有达到了,下次才会发生Mixed GC
G1MixedGCLiveThresholdPercent:old gen region中存活对象的占比,只有在此参数之下,才会被选入CSet
G1MixedGCCountTarget:一次global Concurrent marking之后,最多执行mixed gc的次数
G1OldCSetRegionThresholdPercent:一次Mixed GC中能被选入CSet的最多old generation region数量

#### G1 GC参数
-XX:G1HeapRegionSize=n:设置Region大小,并非最终值
-XX:MaxGCPauseMills:设置G1收集过程目标时间,默认值200ms
-XX:G1NewSizePercent:新生代最小值,默认5%
-XX:G1MaxNewSizePercent:新生代最大值,默认60%
-XX:ParallelGCThreads:STW期间,并行GC线程数
-XX:ConcGCThreads=n:并发标记阶段,并发执行的线程数
-XX:initiatingHeapOccupancyPercent:设置触发标记周期的java堆占用率阀值,默认45%,java堆占比指non_young_capacity_bytes,包括old+humongous

#### Humongous区域
在G1中,如果一个对象占用空间达到或者超过了分区容量50%以上,G1就认为这是一个巨型对象.这些巨型对象默认会直接分配到老年代,但是如果它是一个短期存在的巨型对象,就会对垃圾回收器造成负面影响.为解决这个问题,G1划分了一个Humongous区,用来专门存放巨型对象,如果一个H区存放不下一个巨型对象,那么G1会寻找连续的H分区来存储,为了能找到连续的H区,有时候不得不启动Full GC

将对象分为3中类型:
黑色:根对象,或者该对象与它的子对象都被扫描过(对象被标记了,且它的所有field也被标记完了)
灰色:对象本身被扫描,但是还没有扫描wean该对象的子对象(它的field还没有被标记或标记完)
白色:未被扫描对象,扫描完成所有对象后,最终为白色的为不可达对象,即垃圾对象(对象没有被标记到)

如果在标记过程中，应用程序也在运行中，那么对象的指针就有可能改变，就会导致一个问题：对象丢失问题

#### SATB
在G1中，使用的是SATB(Snapshot At the Beginning)方式，在删除的时候记录所有的对象
有3个步骤：
1.在开始标记时生成一个快照图，标记存活对象
2.在并发标记的时候所有被改变的对象入队（在write barrier你把所有旧的引用所指向的对象都变成非白的）
3.可能存在浮动垃圾，将在下次被收集
对于三色算法在concurrent的时候可能参数的漏标问题,SATB在marking阶段中,对于从gray对象移除的目标引用对象标记为gray,对black引用的新参数的对象标记为black,由于实在开始的时候进行snapshot,因而有可能产生Floating Garbage

SATB可以理解成在GC开始之前对堆内存的对象做一次快照,此时活的对象就认为是活的,从而形成一个对象图
在GC收集的时候,新生代的对象也认为是活的对象,除此之外其他不可达的对象都被认为是垃圾对象

漏标的情况只会发生在白色对象中,且满足以下任意一个条件
1.并发标记时,应用线程该一个黑色对象的引用类型字段赋值了该白色对象
2.并发标记时,应用线程删除所有灰色对象到该白色对象的引用

对于第一种情况,利用post-write barrier,记录所有新增的引用关系,然后根据这些引用关系为根重新扫描一遍
对于第二种情况,利用pre-write barrier,将所有即将被删除的引用关系的旧引用记录下来,最后以这些旧引用为根重新扫描一遍


#### G1 分代算法
1.为老年代设置分区的目的是老年代有的分区垃圾多,有的分区垃圾少,这样在回收时可以专注与收集垃圾多的分区
2.这个算法并不适合新生代垃圾收集,因为新生代垃圾收集算法是复制算法,但是新生代也使用分区机制主要是因为便于代大小的调整

#### G1 停顿预测模型
G1收集器通过一个停顿预测模型根据用户配置的停顿时间来选择CSet的大小,从而达到用户期待的应用程序暂停时间.
通过-XX:MaxGCPauseMillis参数来设置,关于停顿时间的设置并不是越短越好

#### G1的最佳实践
1.不断调优暂停时间指标
2.不要设置新生代和老年代的大小,只需要设置整个堆内存的大小
3.关注Evacuation Failure










